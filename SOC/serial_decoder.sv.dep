// decodes custom serial communication protocol

// once a valid packet is received, valid_pkt will be asserted and cmd and address will be latched to the output
// along with the first value byte of payload
// on the first read cycle (ready_pkt high); cmd, address, and data are valid and must be consumed
// after the first cycle, only data is guaranteed to be valid when valid_pkt is asserted
// on the last valid cycle of the packet, end_of_pkt will be deasserted

module serial_decoder #(CLK_RATE, BAUD_RATE) (
  input  logic clk,
  input  logic reset,

  // UART
  input  logic urx,
  output logic utx,

  // DECODED
  input  logic        ready_pkt,
  output logic        valid_pkt,
  output logic        end_of_pkt,
  output logic [7:0]  pkt_len,
  output logic [7:0]  cmd,
  output logic [31:0] address,
  output logic [7:0]  data
);

  localparam
    START_FRAME = 8'h7E,
    ACK = 8'h06,
    NAK = 8'h15,
    XON = 8'h11,
    XOFF = 8'h13;


  enum {
    IDLE,
    FLOW_CTRL,
    CMD,
    ADDR,
    LEN,
    PAYLOAD,
    CRC,
    SENDERROR,
    SENDACK
  } state, next_state;


  logic [7:0] idx, pkt_remaining;
  logic [7:0] rx_data, tx_data;
  logic rx_valid, tx_ready;
  logic rx_ready, tx_valid;
  logic valid_crc_bit;
  logic crc_reset, crc_error;
  logic commit, revert;
  logic fifo_ready; // TODO send naks or something if we receive data on uart but fifo is full
  logic fifo_write;
  logic fifo_valid;

  assign rx_ready = 1'b1;

  // UART
  uart_rx #(.CLK_RATE, .BAUD_RATE) uart_rx_i (.clk, .reset, .rx(urx), .data(rx_data), .ready(rx_ready), .valid(rx_valid), .valid_crc_bit, .baud_rate_error());
  uart_tx #(.CLK_RATE, .BAUD_RATE) uart_tx_i (.clk, .reset, .tx(utx), .data(tx_data), .ready(tx_ready), .valid(tx_valid));

  crc16 crc16_i (.clk, .reset(crc_reset | reset), .valid(valid_crc_bit), .data(urx), .crc_error);

  spec_fifo #(.WIDTH(8), .DEPTH(256)) spec_fifo_in (.clk, .reset, .commit, .revert, .ready_in(fifo_ready), .valid_in(fifo_write), .data_in(rx_data), 
              .ready_out(ready_pkt), .valid_out(fifo_valid), .data_out(data));


  // process incoming serial packets
  always_ff @(posedge clk)
    if (reset) state <= IDLE;
    else state <= next_state;

  always_comb begin
    next_state = IDLE;
    commit = 1'b0;
    revert = 1'b0;
    fifo_write = 1'b0;

    case (state)
      IDLE : begin 
        if (rx_valid) begin
          if (~fifo_ready)
            next_state = FLOW_CTRL;
          else if (rx_data == START_FRAME)
            next_state = CMD;
          else
            next_state = SENDERROR;
        end else
          next_state = IDLE;
      end

      FLOW_CTRL : begin
        if (tx_valid && tx_ready)
          next_state = IDLE;
        else
          next_state = FLOW_CTRL;
      end

      CMD : begin
        if (rx_valid)
          next_state = ADDR;
        else
          next_state = CMD;
      end

      ADDR : begin
        if (rx_valid && idx == 0)
          next_state = LEN;
        else
          next_state = ADDR;
      end

      LEN : begin
        if (rx_valid)
          next_state = PAYLOAD;
        else
          next_state = LEN;
      end

      PAYLOAD : begin
        fifo_write = rx_valid;
        if (rx_valid && idx == 0)
          next_state = CRC;
        else
          next_state = PAYLOAD;
      end

      CRC : begin
        if (rx_valid && idx == 0) begin
          next_state = crc_error ? SENDERROR : SENDACK;
          commit = ~crc_error;
          revert = crc_error;
        end else
          next_state = CRC;
      end

      SENDERROR : begin
        if (idx == 0)
          next_state = IDLE;
        else
          next_state = SENDERROR;
      end

      SENDACK : begin
        if (idx == 0)
          next_state = IDLE;
        else
          next_state = SENDACK;
      end

      default : next_state = IDLE;
    endcase
  end

  always_ff @(posedge clk) begin
    case (state)
      IDLE : begin
        idx <= 0;
        crc_reset <= 0;
      end

      FLOW_CTRL : begin
        tx_valid <= ~(tx_valid && tx_ready);
        tx_data <= XOFF;
      end

      CMD : begin
        idx <= 3;
        if (rx_valid)
          cmd <= rx_data;
      end

      ADDR : begin
        if (rx_valid) begin
          address[8*idx+:8] <= rx_data;
          idx <= idx - 1;
        end
      end

      LEN : begin
        if (rx_valid) begin
          idx <= rx_data-1;
          pkt_len <= rx_data;
        end
      end

      PAYLOAD : begin
        if (rx_valid) begin
          if (idx == 0)
            idx <= 1;
          else
            idx <= idx - 1;
        end
      end

      CRC : begin
        if (rx_valid) begin
          if (idx == 0) begin
            crc_reset <= 1;
            idx <= 1;
          end else
            idx <= idx - 1;
        end
      end

      SENDACK : begin
        tx_valid <= 1;
        tx_data <= ACK;
        if (idx == 0)
          tx_valid <= 0;
        else if (tx_ready)
          idx <= idx - 1;
      end

      SENDERROR : begin
        tx_valid <= 1;
        tx_data <= NAK;
        if (idx == 0)
          tx_valid <= 0;
        else if (tx_ready)
          idx <= idx - 1;
      end

    endcase
  end

  // packet valid logic
  assign valid_pkt = (pkt_remaining != 0) && fifo_valid;
  assign end_of_pkt = (pkt_remaining == 1);

  always_ff @(posedge clk) begin
    if (reset) begin
      pkt_remaining <= '0;
    end else begin
      if (commit)
        pkt_remaining <= pkt_len;
      else if (valid_pkt && ready_pkt)
        pkt_remaining <= pkt_remaining - 1;
    end
  end

endmodule // serial_decoder
